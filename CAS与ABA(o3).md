CAS 指令本身确实是“比较 + 写入”一气呵成、不可分割的原子操作，但 ABA 并不是发生在 **这条指令的原子性** 上，而是发生在 **“你获得期望值”到“真正执行这条 CAS 指令”之间的时间窗口** 上。只要你明白下面两层时间轴的差距，ABA 就顺理成章了。  

---

## 1. 两条时间线：你的算法 vs. 硬件指令

```
       线程代码视角（高层）
T1 ──┬─ 1. old = load(addr)     ← 普通读
      │                          （此时 old == A）
      │
      │ 2.  ……做点别的事……
      │
      │ 3. CAS(addr, old(A), new(C))   ← 原子指令
      │
CPU ──┴─────────────────────────────────────
          ↑                 ↑
         t0                t3      ← 指令在 t3 原子完成
      (取期望值)         (真正执行 CAS)
```

CAS 的原子性只覆盖 **t3 这一瞬间**。  
然而 **t0~t3** 之间，你把 `old` 这个“期望值”暂时存放在寄存器或变量里，它并不受 CPU 保护。别的线程完全可以：

T2 在 t1 把值 A → B  
T2 在 t2 把值 B → A（或重新 malloc 了一块恰好值也是 A 的内存）  

等到 t3 你执行 CAS 时，内存里的值又是 A，于是比较成功，CAS 认为“没人改过”。—— **硬件保证不了这段“逻辑空窗期”的正确性**，这就是 ABA。

---

## 2. 把时序展开就一目了然

下面用时序图把 T1、T2 的操作放一起看（A→B→A 场景）：

```
时间  T1                            T2
 t0   old = load(addr)  // 读到 A
 t1                           CAS(addr, A, B) 成功
 t2                           CAS(addr, B, A) 成功
 t3   CAS(addr, old(A), C)  // 依旧比较成功
```

注意：  
• T1 的 **读 old** 与 **CAS** 之间没有原子性，  
• T2 的两次 CAS 各自都是原子的，却仍然能在 gap 里做完“变—再变回”。

---

## 3. 为什么只写“一条 CAS 就完事”的代码仍然免不了读‑写分离？

99% 的无锁算法伪代码都会长这样👇

```c
do {
    old = atomic_load(addr);   // 普通原子读
    new = f(old);              // 生成新值
} while (!CAS(addr, old, new)); // 如果失败，重试
```

• `atomic_load` 虽然是“原子读”，但它 **只是保证读操作不被 torn**；  
• 它和后面的 CAS **不是同一条指令**，所以仍存在时序间隙；  
• 只要算法逻辑依赖“old 没被改动过”，就要小心 ABA。

极端做法是“完全不提前读，直接用单指令 SWAP”：

```c
// x86 有 XCHG；ARM 有 LDAXR+STLXR with exclusive monitor
new = ...                // 已知想写的值
old = atomic_exchange(addr, new);
```

这种“纯交换”没有 ABA，因为根本不需要比较。但绝大多数无锁结构需要 **先读再比较** 才知道下一个指针、计数或版本号，新值不是事先写死的，所以避免不了“读‑→‑写”两步。

---

## 4. 再次强调：原子性 ≠ 线性不可见性

CAS 保证的是：

1. 比较 + 写入这两步“要么一起发生，要么都不发生”；  
2. 对其他 CPU 来说，它表现得像在某个瞬间完成。

CAS **没有保证**：

• 从你获取期望值开始，到你真正执行 CAS 结束，中间 memory cell 没被别人改动过。  

所以 ABA 与“指令失效”无关，它是 **算法层的语义漏洞**。

---

## 5. 如果不用锁，怎么补这个漏洞？

经典办法就是“让比较的东西不仅仅是值本身”：  

1. (值, 版本号)  打包：A→B→A 时版本变 1→2→3，CAS 能看出来。  
2. Hazard Pointer / Epoch：即使指针回到原地址，那块内存在逻辑上已判定“废弃”，不会马上重用。  
3. Pointer Tagging：指针低位嵌入计数器，每次改动就 +1。  

这样即使硬件看不见“中途改动”本身，也能看见“版本不一致”，从而发现 ABA。

---

## 6. 小结

• CAS 的比较与写入确实是原子，但 **算法必须先拿到要比较的预期值**；  
• 预期值与内存单元在接下来的时间里可能“分道扬镳”，从而产生 A→B→A 的假象；  
• 因此 ABA 是“算法级别的竞态”，不是“指令级别的不原子”；  
• 要么给比较的元组增加不可回滚的信息（版本号、标记位），要么靠更高级的内存回收协议；否则就乖乖用锁。